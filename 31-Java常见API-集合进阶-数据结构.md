# Java 常见 API 集合进阶之数据结构

## 一、树（Tree）结构

树结构，由一个个结点（节点）组成。

结点与结点之间的关系有：父节点，左子节点、右子结点。

![树结构](NodeAssets/树结构.jpg)

每个结点中，存储了元素值，父结点地址值、左子结点地址值、右子结点地址值。

![树的结点](NodeAssets/树的结点.jpg)

如果一个结点，没有父节点，或者子节点，那么相应的位置记为 `null`。

树结构中的专业名词：

- 度：每一个结点的子节点数量。
- 高度：树结构的层数，上图中的二叉树，就是一个高度为 4 的树。
- 根节点：树结构中最顶层的结点。
- 左子节点：结点左下方的结点。
- 右子结点：结点右下方的结点。
- 左子树：结点左下方的子树。
- 右子树：结点右下方的子树。

### 1.二叉树

在树结构中，任意节点的度，都小于等于 2 的树，称为二叉树。

![普通二叉树](NodeAssets/普通二叉树.jpg)

二叉树有四种遍历方式：

- 前序遍历：指的是从根节点开始，按照当前结点，左子节点、右子结点的顺序遍历。
- 中序遍历（用得较多）：指的是从根节点开始，按照左子节点，当前节点，右子结点的顺序遍历。
  - 使用这种遍历方式，遍历二叉查找树，会按照从小到大的方式遍历。
- 后序遍历：指的是从根节点开始，按照左子节点，右子结点，当前节点的顺序遍历。
- 层序遍历：从根节点开始，一层一层的进行遍历。

二叉树的弊端：元素存储毫无规律，查找时必须要挨个遍历查找。

### 2.二叉查找树

二叉查找树，又称为“二叉排序树”、“二叉搜索树”。

![二叉查找树](NodeAssets/二叉查找树.jpg)

二叉查找树，有如下特点：

- 每一个节点上最多有两个子节点
- 任意节点左子树上所有节点的值，都小于当前结点的值
- 任意节点右子树上所有节点的值，都大于当前结点的值

所以，二叉查找树在存入、查找元素的时候，效率高；遵循的规则是：小的存（查）左边，大的存（查）右边。一样的不存。

二叉查找树的弊端：

- 当元素分布不均匀时，二叉查找树接近于链表的结构，查询效率慢。

### 3.平衡二叉树

平衡二叉树要求：

- 在二叉查找树的基础上，**任意结点**左右子树高度差，不超过 1；
- 任意节点的左右两个子树都是一颗平衡二叉树。

平衡二叉树，保持平衡要靠旋转机制。

- 旋转触发时机：当添加一个节点之后，该树不再是一颗平衡二叉树时。
- 旋转的规则：左旋；右旋。

平衡二叉树，旋转的步骤：

1. 从添加的结点开始，不断的往父节点找不平衡的结点。
2. 以找到的不平衡结点，作为**支点**，进行左旋，或者右旋。

#### 1.平衡二叉树旋转情况

##### 1.左旋情况一

左旋情况一，支点没有左子节点：

1. 从添加的结点开始，找到支点（不平衡的结点）；
2. 晋升支点的右子结点，把支点左旋降级为该结点的左子节点。。

旋转前：

![左旋情况一-旋转前](NodeAssets/左旋情况一-旋转前.jpg)

旋转后：

![左旋情况一-旋转后](NodeAssets/左旋情况一-旋转后.jpg)

##### 2.左旋情况二

左旋情况一，支点有左子节点：

1. 从添加的结点开始，找到支点（不平衡的结点）；
2. 晋升支点的右子结点，
   1. 把支点左旋降级为该结点的左子节点。
   2. 把该节点的左子节点，出让给降级支点，作为它的右子结点。

旋转前：

![左旋情况而-旋转前](NodeAssets/左旋情况二-旋转前.jpg)

旋转后：

![左旋情况二-旋转后](NodeAssets/左旋情况二-旋转后.jpg)

##### 3.右旋情况一

右旋情况一，支点没有右子节点：

1. 从添加的结点开始，找到支点（不平衡的结点）；
2. 晋升支点的左子结点，把支点右旋降级为该结点的右子节点。

旋转前：

![右旋情况一-旋转前](NodeAssets/右旋情况一-旋转前.jpg)

旋转后：

![右旋情况一-旋转后](NodeAssets/右旋情况一-旋转后.jpg)

##### 4.右旋情况二

右旋情况一，支点有右子节点：

1. 从添加的结点开始，找到支点（不平衡的结点）；
2. 晋升支点的左子结点，
   1. 把支点右旋，降级为该结点（晋升的左子节点）的右子节点。
   2. 把该节点（晋升的左子节点）的右子节点，出让给降级支点，作为它的左子结点。

旋转前：

![右旋情况而-旋转前](NodeAssets/右旋情况二-旋转前.jpg)

旋转后：

![右旋情况二-旋转后](NodeAssets/右旋情况二-旋转后.jpg)

#### 2平衡二叉树旋转时机

##### 1.左左

左左: 当根节点左子树的左子树，有节点插入，导致二叉树不平衡

如何旋转：对整体进行**一次右旋**即可。

![平衡二叉树左左](NodeAssets/平衡二叉树左左.png)

##### 2.左右

左右: 当根节点左子树的右子树，有节点插入，导致二叉树不平衡

如何旋转：先在左子树对应的节点位置进行局部左旋，再对整体进行右旋

在左子树对应的节点位置进行局部左旋

![平衡二叉树左右局部左旋](NodeAssets/平衡二叉树左右局部左旋.jpg)

得到：

![平衡二叉树左右局部左旋2](NodeAssets/平衡二叉树左右局部左旋2.jpg)

再对整体进行右旋：

![平衡二叉树左右整体右旋](NodeAssets/平衡二叉树左右整体右旋.jpg)

##### 3.右右

右右: 当根节点右子树的右子树，有节点插入，导致二叉树不平衡。

如何旋转: 直接对整体进行一次左旋即可。

![平衡二叉树右右](NodeAssets/平衡二叉树右右.png)

##### 4.右左

右左：当根节点右子树的左子树，有节点插入，导致二叉树不平衡。

如何旋转: 先在右子树对应的节点位置进行局部右旋，再对整体进行左旋

先在右子树对应的节点位置进行局部右旋:

![平衡二叉树右左局部右旋1](NodeAssets/平衡二叉树右左局部右旋1.jpg)

得到：

![平衡二叉树右左局部右旋2](NodeAssets/平衡二叉树右左局部右旋2.jpg)

再对整体进行左旋：

![平衡二叉树右左左旋](NodeAssets/平衡二叉树右左左旋.jpg)

平衡二叉树优势，查找效率很高；

平衡二叉树弊端：在添加结点时，旋转次数过多，导致效率偏低。

### 4.红黑树

1972 年出现“平衡二叉 B 树”，1978 年改名为如今的“红黑树”。

红黑树是一种自平衡的二叉查找树，是计算机科学中用到的一种数据结构。

红黑树是一种特殊的**二叉查找树**，它的每一个结点上，都有存储位，表示结点的颜色（红或黑）。

红黑树不是高度平衡的，它的平衡通过“红黑规则”实现。

#### 1.红黑规则

1. 每一个节点要么是红色的，要么是黑色的；

2. 根节点必须是黑色；

3. 如果一个节点没有子节点，或者父节点，则该节点相应的指针属性值为 **Nil**，这些 Nil 视为**叶节点,**，每个叶节点（Nill）都是黑色的。

4. 如果某一个节点是红色，那么它的子节点，必须是黑色（不能出现两个红色节点相连的情况）。

5. 对每一个节点,从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点。

> 简单路径：只能向后找，不能向前找。

![红黑树](NodeAssets/红黑树.jpg)

红黑树中的每个结点中，存放了以下数据：

- 父节点地址值。
- 元素值
- 左子节点地址值。
- 右子结点地址值。
- 颜色。
